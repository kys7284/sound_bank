input {
  file {
    path => "/usr/share/logstash/logs/app.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => multiline { 
      pattern => "^%{TIMESTAMP_ISO8601}"         # 새 로그의 시작은 날짜로 시작함
      negate => true
      what => "previous"
	  auto_flush_interval => 1 # 1초 안에 다음 줄 안 오면 강제 flush
	  charset => "UTF-8"  # 또는 UTF-8, 깨지지 않는 걸로!
    }
  }
}

filter {
  grok {
    match => {
      "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:level}\] %{GREEDYDATA:msg}"
    }
    remove_field => ["message"]
  }

  # log-test용
  if "log-test" in [msg] {
    grok {
      match => {
        "msg" => "log-test \| user_id=%{WORD:user_id} \| action=%{WORD:action}"
      }
    }
  }

  # ex-log용 (customer_id 대응!)
  if "ex-log" in [msg] {
    grok {
      match => {
        "msg" => "ex-log\s+\|\s+customer_id=%{WORD:customer_id}\s+\|\s+action=%{WORD:action}\s+\|\s+currency_code=%{WORD:currency_code}"

      }
    }
	mutate{
	  add_tag => ["exlog_parsed"]
	}
  }

  mutate {
    gsub => ["msg", "\r", ""]
  }

  date {
    match => ["timestamp", "yyyy-MM-dd HH:mm:ss"]
    target => "@timestamp"
    timezone => "Asia/Seoul"
  }
}



output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "spring-log-%{+YYYY.MM.dd}"
  }
  stdout { codec => rubydebug }
}
